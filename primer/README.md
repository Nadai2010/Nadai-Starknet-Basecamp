<div align="center">
    <h1>Primer</h1>

|Presentation|Video|Definitions
|:----:|:----:|:----:|
|[Validity Rollups](https://drive.google.com/file/d/1UqYi482bpVyXO4nWkogmIXq281q70f6y/view?usp=sharing)|[StarkNet 101](https://www.youtube.com/watch?v=DrBJ9LWvsOQ)|[Perama Blog](https://perama-v.github.io/cairo/description)
</div>

### Topics

1. [Bitcoin](./bitcoin/README.md)
2. [Smart Contracts](#smart_contracts)
3. [Ethereum](./ethereum/README.md)
4. [Rollups](./rollups/README.md)

<h2 align="center">Overview</h2>
Este manual est√° dise√±ado para cubrir los conceptos introductorios sobre lo que se construye en Cairo y StarkNet, y tambi√©n para que se familiarice con el formato de este curso. Cada secci√≥n implicar√° profundizar en un concepto de alto nivel relacionado con StarkNet o Cairo hasta que lleguemos a un concepto "at√≥mico" o irreducible que podamos representar en un ejemplo de c√≥digo simple/ejecutable:


<div align="center">
    <img src="../misc/plat.png">
</div>

Los ejemplos de c√≥digo ser√°n nombrados por el lenguaje de programaci√≥n en el que se implementan, por ejemplo, la verificaci√≥n de bloques de Bitcoin en [Golang](https://go.dev/doc/install) (si puede implementar estos ejemplos en otros idiomas, nos encantar√≠a PR):

<div align="center">
    <a href="./bitcoin/block_verification/go">bitcoin/block_verification/go</a>
</div>

Los temas tratados en este manual han sido discutidos de cientos de maneras por miles de personas, por lo que, siempre que sea posible, me vincular√© a esos recursos.

<div align="center">
    <em>De pie sobre los hombros de gigantes, bla, bla, bla, vamos a lo bueno</em>
</div>

<h3 align="center"> ¬øPara que estamos resolviendo?</h3>
El advenimiento de la tecnolog√≠a blockchain le ha dado al mundo sistemas computacionales con absoluta transparencia y responsabilidad inclusiva. Para obtener estas caracter√≠sticas, los sistemas de cadena de bloques se han visto obligados a realizar grandes compensaciones que afectan la usabilidad. Vitalik Buterin, resumi√≥ este problema en "The Blockchain Trilemma" afirmando:

<br>
<br>
<div align="center">
    <em>las cadenas de bloques se ven obligadas a hacer concesiones que les impiden ser descentralizadas, escalables y seguras.</em>
</div>
<br>

En este curso, aprender√° c√≥mo StarkWare intenta abordar el Blockchain Trillemma y proporcionar un sistema que es inclusivamente responsable, descentralizado, escalable y seguro mediante el uso de pruebas STARK de conocimiento cero.

<p align="center">
    üéØ
    <strong>Retos: </strong>
    Segura, inclusivamente responsable, descentralizada, escalable, expresiva
    üéØ
</p>

<h2 align="center"> Evoluci√≥n de la seguridad de los datos</h2>
<div align="center">
    <img src="../misc/evolution.png">
</div>

Para un ejemplo m√°s concreto de trillemna, podemos movernos completamente fuera del contexto de la cadena de bloques. Digamos que Alice tiene un dato importante al que necesita acceder. Para empezar representaremos estos datos como caracteres ascii en formato YAML:

```yaml
alice_account: 5.00
```

Escrib√°moslo en un archivo en el disco de nuestra computadora y midamos el rendimiento:

```bash
time echo "alice_account: 5.00" >> bank.yaml
```

Leamos esa informaci√≥n:

```bash
time cat bank.yaml
```

Obviamente, es muy r√°pido leer y escribir estos datos desde nuestro disco local, y se pueden aplicar poderosos [mecanismos de base de datos](https://www.postgresql.org) para optimizar los accesos a los datos. PERO si deja caer su computadora o se acerca demasiado a un gran im√°n ACME, Alice pierde la valiosa informaci√≥n de su cuenta bancaria.
<p align="center">
    üéØ
    <strong>Goals: </strong>
    <s style="color: red">secure</s>,
    <s style="color: red">inclusively accountable</s>,
    <s style="color: red">decentralized</s>,
    <span style="color: green">scalable</span>,
    <span style="color: green">expressive</span>
    üéØ
</p>
<p align="center">
    üí°
    <strong>Vamos a replicar la cuenta de Alice en otra computadora</strong>
    üí°
</p>
Si replicamos el archivo YAML de la cuenta bancaria de Alice en varias computadoras, cuando una falla, ¬°no hemos perdido los datos!

Preguntas del remitente:

- ¬øC√≥mo ubico un host receptor al que enviar?
- ¬øC√≥mo s√© que el host receptor escribi√≥ con √©xito los datos de la cuenta de Alice?
- Si cambio el valor de la cuenta de Alice, ¬øc√≥mo sabr√° el host receptor que actualice el mismo valor?

Preguntas del receptor:

- ¬øDe qui√©n recibir√© datos?
- Si cambio el valor de la cuenta de Alice, ¬øc√≥mo sabr√° el host de env√≠o que debe actualizar el mismo valor?

### Sistemas distribuidos

Estas preguntas forman la base de los sistemas distribuidos y la computaci√≥n distribuida a trav√©s de una red, y se han estudiado desde el inicio de Internet.

Veamos brevemente c√≥mo una de las bases de datos distribuidas m√°s populares [CassandraDB](https://cassandra.apache.org/doc/latest/cassandra/getting_started/configuring.html) maneja estos problemas.

Al configurar el sistema, puede ver que debe incluir en la lista blanca las direcciones IP del 'nodo semilla' que formar√°n nuestro cl√∫ster de confianza que participar√° en un [gossip](https://www.linkedin.com/pulse/gossip-protocol-inside-apache-cassandra-soham-saha) de igual a igual limitado. Aunque esto es adecuado para muchos sistemas tradicionales, nos esforzamos por construir sistemas inclusivos y sin permisos.

Una vez que se configura la base de datos distribuida, obtenemos "Tolerancia a fallas" para los valiosos datos bancarios de Alice. Si alguien trae accidentalmente su gran im√°n ACME a un centro de datos, se puede acceder f√°cilmente a los datos en hosts redundantes. De manera similar a las cadenas de bloques, estos sistemas distribuidos hicieron concesiones al ejemplo simple de I/O anterior. 

Entonces, ¬øa qu√© renunciamos por esta tolerancia a fallas?

Perspectiva de los bancos:

- La sobrecarga de la red afecta el rendimiento
- La redundancia y la replicaci√≥n afectan el rendimiento
- Mantenimiento de infraestructura ($$$$)

La perspectiva de Alicia:

- Delegados de confianza al banco:
  - la base de datos est√° configurada correctamente
  - la seguridad operativa puede manejar atacantes o intrusos
  - no est√° haciendo nada enga√±oso
  - etc.
- Los costos generalmente se pasan a Alice
<p align="center">
    üéØ
    <strong>Goals: </strong>
    <span style="color: yellow">secure</span>,
    <s style="color: red">inclusively accountable</s>,
    <s style="color: red">decentralized</s>,
    <span style="color: green">scalable</span>,
    <span style="color: green">expressive</span>
    üéØ
</p>
<p align="center">
    üí°
    <strong>Vamos a replicar la cuenta de Alice en CUALQUIER computadora</strong>
    üí°
</p>

### [Bitcoin](./bitcoin/README.md)

Bitcoin re√∫ne varios conceptos inform√°ticos junto con la [game theory](https://en.wikipedia.org/wiki/Game_theory) para crear una verdadera red peer-to-peer y niega la necesidad de delegar nuestra confianza en una parte central.

Los nodos conf√≠an en el productor de bloques en funci√≥n de su [proof of work](./bitcoin/proof_of_work) y la red acuerda colectivamente un conjunto de actualizaciones can√≥nicas del estado del libro mayor de Bitcoin y el estado de la cuenta de Alice.

```bash
# proof of work example
cd bitcoin/proof_of_work/go
go run main.go
```

Los propios nodos de Bitcoin escuchan y [validate](./bitcoin/block_verifcation) bloques de transacciones que el minero de ese bloque transmite a la red. Forman una estructura de datos llamada Merkle Tree para obtener un hash ra√≠z correspondiente a todas las transacciones (y su orden) en ese bloque. Si un tx cambia incluso un solo bit, la ra√≠z de Merkle ser√° completamente diferente.

```bash
# block verification example
cd bitcoin/block_verification/go && go mod tidy
go run main.go utils.go
```

La informaci√≥n de Alice se formatea como [UTXO](https://en.wikipedia.org/wiki/Unspent_transaction_output) y se replica en todos los [nodos](https://bitnodes.io) en la red Bitcoin. Incluso puede validar que todo es exacto por s√≠ misma repasando el √°rbol merkle de cada bloque de transacciones desde el g√©nesis hasta ahora.
<p align="center">
    üéâ
    <strong>NO DELEGATION OF TRUST</strong>
    üéâ
</p>
Repasemos el trillema. ¬øA qu√© renunciamos para obtener esta seguridad de datos sin confianza?

- Los mineros gastan energ√≠a mientras intentan obtener el nonce
- La verificaci√≥n sin confianza completa requiere que CADA nodo replique el estado can√≥nico:
   - hash el √°rbol merkle de transacciones
   - hash el encabezado del bloque

Tama√±o de nodo completo: ~405 GB
  
Para una demostraci√≥n ingenua de "La evoluci√≥n de la seguridad de los datos", ejecute lo siguiente:
```bash
cd bitcoin/block_verification/go && go mod tidy
go test ./... -bench=. -count 5
```

<p align="center">
    üéØ
    <strong>Goals: </strong>
    <span style="color: green">secure</span>,
    <span style="color: green">inclusively accountable</span>,
    <span style="color: green">decentralized</span>,
    <s style="color: red">scalable</s>,
    <s style="color: red">expressive</s>
    üéØ
</p>
<p align="center">
    üí°
    <strong>Dejemos que Alice use sus datos</strong>
    üí°
</p>

<h2 align="center" id="smart_contracts">Smart Contracts</h2>

Los contratos inteligentes fueron propuestos por primera vez por [Nick Szabo](https://www.fon.hum.uva.nl/rob/Courses/InformationInSpeech/CDROM/Literature/LOTwinterschool2006/szabo.best.vwh.net/smart.contracts.html ) como un protocolo de transacci√≥n que ejecuta los t√©rminos de un contrato, brindando a todas las partes transparencia en el conjunto de reglas y la ejecuci√≥n. Bitcoin facilita una versi√≥n limitada de [contratos inteligentes](https://ethereum.org/en/whitepaper/#scripting), pero el expresivo modelo de contrato inteligente de Ethereum se ha adoptado m√°s ampliamente.
<h2 align="center">Ethereum</h2>

Ethereum proporciona una plataforma para implementar estos contratos inteligentes con el uso de la [Ethereum Virtual Machine](./ethereum/ethereum_virtual_machine). En el paradigma Ethereum, la informaci√≥n de la cuenta bancaria de Alice se almacena en una direcci√≥n de 20 bytes llamada [cuenta] (https://ethereum.org/en/whitepaper/#ethereum-accounts). El saldo de su cuenta junto con algunos campos m√°s (nonce, storageRoot, codeHash) se convierten en un "nodo" en una estructura de datos llamada Patricia Trie, donde PATRICIA significa "Algoritmo pr√°ctico para recuperar informaci√≥n codificada en alfanum√©rico".

Este 'Trie' es un tipo espec√≠fico de √°rbol que codifica una 'clave' como una ruta de prefijos comunes a su 'valor' correspondiente. Entonces, la cuenta bancaria de Alice se puede encontrar en una direcci√≥n ("clave") que apunta a una cuenta ("valor") en el estado mundial de Ethereum (trie). La estructura de √°rbol del trie nos permite obtener un hash criptogr√°fico de cada nodo hasta un solo hash correspondiente a la "ra√≠z" similar al √°rbol de Merkle que vimos en la verificaci√≥n del bloque de Bitcoin.

Para ver un ejemplo de la estructura de datos MPT, puede usar este diagrama como referencia:

<div align="center">
    <img src="../misc/trie.png">
</div>

y ejecuta lo siguiente:

```bash
cd ethereum/block_verification/go && go mod tidy
go run *.go
```

Luego, Ethereum propaga su estado al verificar que las transacciones est√©n bien formadas y aplicarlas a las cuentas. Alice tiene un par de claves p√∫blica/privada para administrar su "cuenta de propiedad externa" y puede firmar transacciones que involucren su saldo o impliquen interactuar con otros contratos en el estado.

Adem√°s de los EOA, Ethereum tiene "cuentas de contrato" que est√°n controladas por el c√≥digo de contrato asociado a ellas. Cada vez que la cuenta del contrato recibe un mensaje, el c√≥digo de bytes que se almacena como un valor [codificado en RLP](https://eth.wiki/fundamentals/rlp) en el almacenamiento de la cuenta comienza a ejecutarse de acuerdo con las reglas de EVM.

Visita Trillemma: ¬øa qu√© renunciamos para sumar expresividad?

- Cada transacci√≥n a√∫n debe ser procesada por cada nodo de la red.
- Con la adici√≥n del almacenamiento de estado mundial, la cadena de bloques puede "inflarse", lo que lleva a un riesgo de centralizaci√≥n
- Alice puede pagar $100 para usar el dinero en su cuenta

Tama√±o de nodo completo: ~700 GB

Tama√±o del nodo de archivo: ~10 TB

<p align="center">
    üéØ
    <strong>Goals: </strong>
    <span style="color: green">secure</span>,
    <span style="color: green">inclusively accountable</span>,
    <span style="color: green">decentralized</span>,
    <s style="color: red">scalable</s>,
    <span style="color: green">expressive</span>
    üéØ
</p>
<p align="center">
    üí°
    <strong>Optimicemos la utilidad de datos de Alice</strong>
    üí°
</p>

<h2 align="center"> Rollups</h2>

A medida que aumenta la demanda de espacio en bloque, el costo de ejecuci√≥n en la "Capa 1" (protocolos de consenso total, por ejemplo, Bitcoin, Ethereum) ser√° cada vez m√°s costoso, y hasta ciertos [state expiry mechanisms](https://notes.ethereum.org/@vbuterin/verkle_and_state_expiry_proposal) se implementan y podemos esperar que el estado de la L1 contin√∫e aumentando con el tiempo. Esto requerir√° una m√°quina cada vez m√°s robusta para mantener el estado y posteriormente verificar los bloques.

Los rollups son una soluci√≥n en la que la l√≥gica empresarial se ejecuta y almacena en un protocolo fuera del contexto de Ethereum y luego demuestra su ejecuci√≥n exitosa en el contexto de Ethereum.

Por lo general, esto implica comprimir una mayor cantidad de transacciones en esta "Capa 2" y comprometer las diferencias de estado en un contrato inteligente implementado en L1.
Para una interoperabilidad total con los paquetes acumulativos L1, tambi√©n suele implementar un componente de mensajer√≠a para dep√≥sitos y retiros.

Actualmente hay dos tipos de acumulaciones que se est√°n adoptando ampliamente:

- Paquetes acumulativos optimistas
- Paquetes acumulativos de conocimiento cero

Vitalik proporciona una buena comparaci√≥n de los dos [aqu√≠](https://vitalik.ca/general/2021/01/05/rollup.html#optimistic-rollups-vs-zk-rollups), y toca las piezas finales de nuestro largo
viaje del trilema:

***No importa cu√°n grande sea el c√°lculo, la prueba se puede verificar muy r√°pidamente en la cadena.***

Esto le permite a Alice mover su dinero libremente entre L1 y L2 (... pronto ser√° L3) y operar en una capa expresiva de cadena de bloques de bajo costo.
¬°Todo mientras hereda la forma m√°s alta de evoluci√≥n de seguridad de datos de L1 y no tiene que delegar la confianza a ninguna parte centralizada!

<p align="center">
    üéØ
    <strong>Goals: </strong>
    <span style="color: green">secure</span>,
    <span style="color: green">inclusively accountable</span>,
    <span style="color: green">decentralized</span>,
    <span style="color: green">scalable</span>,
    <span style="color: green">expressive</span>
    üéØ
</p>

<p align="center">
    üéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâ
</p>
